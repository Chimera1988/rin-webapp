<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>–†–∏–Ω –ê–∫–∏—Ö–∞—Ä–∞ ‚Äî —Ç–≤–æ–π –∫–æ–º–ø–∞–Ω—å–æ–Ω</title>
  <link rel="stylesheet" href="/style.css" />

  <!-- ‚úÖ –ê–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ª–æ–≥–∏–Ω, –µ—Å–ª–∏ PIN –µ—â—ë –Ω–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω -->
  <script>
    if (!localStorage.getItem('rin-pin')) {
      window.location.href = '/login.html';
    }
  </script>
</head>
<body>

  <header class="tg-header">
    <button class="tg-ico btn-back" aria-label="–ù–∞–∑–∞–¥" title="–ù–∞–∑–∞–¥">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
        <path d="M15 6L9 12L15 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div class="tg-peer">
      <img id="avatarTop" class="avatar" src="/avatar.jpg" alt="–†–∏–Ω" />
      <div class="peer-meta">
        <div class="peer-name">–†–∏–Ω –ê–∫–∏—Ö–∞—Ä–∞</div>
        <div id="peerStatus" class="peer-status">–æ–Ω–ª–∞–π–Ω</div>
      </div>
    </div>
    <div class="tg-actions"></div>
  </header>

  <main class="app">
    <section id="chat" class="chat" aria-live="polite"></section>

    <form id="form" autocomplete="off">
      <input id="input" type="text" placeholder="–ù–∞–ø–∏—à–∏ –†–∏–Ω‚Ä¶" maxlength="1000" required />
      <button id="send" type="submit" aria-label="–û—Ç–ø—Ä–∞–≤–∏—Ç—å">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="currentColor"/>
        </svg>
      </button>
    </form>
  </main>

  <script>
  const STORAGE_KEY = 'rin-history-v2';
  const DAILY_INIT_KEY = 'rin-init-count';

  const chatEl  = document.getElementById('chat');
  const formEl  = document.getElementById('form');
  const inputEl = document.getElementById('input');
  const peerStatus = document.getElementById('peerStatus');

  let persona = null, phrases = null, schedule = null, stickers = null;
  let history = [];
  let chainStickerCount = 0;

  const nowLocal = () => new Date();
  const fmtDateKey = (d) => d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0')+'-'+String(d.getDate()).padStart(2,'0');

  function loadHistory(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); } catch { return []; } }
  function saveHistory(h){ localStorage.setItem(STORAGE_KEY, JSON.stringify(h.slice(-60))); }

  function getInitCountFor(dateKey){ const data = JSON.parse(localStorage.getItem(DAILY_INIT_KEY) || '{}'); return data[dateKey] || 0; }
  function bumpInitCount(dateKey){ const data = JSON.parse(localStorage.getItem(DAILY_INIT_KEY) || '{}'); data[dateKey] = (data[dateKey] || 0) + 1; localStorage.setItem(DAILY_INIT_KEY, JSON.stringify(data)); }

  function ensureDateDivider(dateObj){
    const lastDivider = chatEl.querySelector('.date-divider:last-of-type');
    const today = new Date(); const todayKey = fmtDateKey(today);
    const msgKey = fmtDateKey(dateObj);
    if (lastDivider && lastDivider.dataset.key === msgKey) return;
    const label = (() => {
      const yesterday = new Date(); yesterday.setDate(today.getDate()-1);
      const yKey = fmtDateKey(yesterday);
      if (msgKey === todayKey) return phrases?.date_dividers?.today || '–°–µ–≥–æ–¥–Ω—è';
      if (msgKey === yKey)    return phrases?.date_dividers?.yesterday || '–í—á–µ—Ä–∞';
      return msgKey.split('-').reverse().join('.');
    })();
    const div = document.createElement('div');
    div.className = 'date-divider';
    div.dataset.key = msgKey;
    div.innerHTML = `<span>${label}</span>`;
    chatEl.appendChild(div);
  }

  function addBubble(text, who='assistant', ts = Date.now()){
    const dateObj = new Date(ts);
    ensureDateDivider(dateObj);
    const row = document.createElement('div');
    row.className = 'row ' + (who === 'user' ? 'me' : 'her');
    if (who !== 'user') {
      const ava = document.createElement('img');
      ava.className = 'avatar small';
      ava.src = '/avatar.jpg';
      ava.alt = '–†–∏–Ω';
      row.appendChild(ava);
    } else {
      const spacer = document.createElement('div');
      spacer.className = 'avatar small spacer';
      row.appendChild(spacer);
    }
    const wrap = document.createElement('div');
    wrap.className = 'bubble ' + (who === 'user' ? 'me' : 'her');
    wrap.textContent = text;
    row.appendChild(wrap);
    chatEl.appendChild(row);
    chatEl.scrollTop = chatEl.scrollHeight;
  }

  function addTyping(){
    const row = document.createElement('div');
    row.className = 'row her typing-row';
    row.innerHTML = `<img class="avatar small" src="/avatar.jpg" alt="–†–∏–Ω" />
      <div class="bubble her typing"><span></span><span></span><span></span></div>`;
    chatEl.appendChild(row);
    chatEl.scrollTop = chatEl.scrollHeight;
    return row;
  }

  // ---------- helpers ----------
  function weightedPick(arr){
    const total = arr.reduce((s,a)=>s+(a.weight||1),0);
    let r = Math.random()*total;
    for (const a of arr){ r -= (a.weight||1); if (r <= 0) return a; }
    return arr[0];
  }
  function hourMood(){
    const h = new Date().getHours();
    if (h >= 6 && h < 12) return 'morning';
    if (h >= 12 && h < 18) return 'day';
    if (h >= 18 && h < 23) return 'evening';
    return 'night';
  }

  // ------- STICKERS: SMART PICK (v2 priority: userText) -------
  function pickStickerSmart(replyText, windowPool, userText) {
    if (!stickers || stickers._schema !== 'v2') return null;
    const list = stickers.stickers || [];
    if (!list.length) return null;

    const DISCOURAGE = /(—Ç—è–∂–µ–ª|—Ç—è–∂—ë–ª|–≥—Ä—É—Å—Ç|–±–æ–ª—å–Ω–æ|—Ç—Ä–µ–≤–æ–≥|—Å–ª–æ–∂–Ω–æ|–ø—Ä–æ–±–ª–µ–º|–ø–æ–º–æ–≥–∏|—Å–æ–≤–µ—Ç|–ø–ª–∞–Ω|–≥—Ä–∞–Ω–∏—Ü)/i;
    const KEY_FLIRT = /(–æ–±–Ω–∏–º|–ø–æ—Ü–µ–ª|—Å–∫—É—á|–Ω—Ä–∞–≤|—Ö–æ—á—É —Ç–µ–±—è|—Ä—è–¥–æ–º|–ª—é–±–ª—é|–Ω–µ–∂)/i;

    // 0) –ø—Ä—è–º–æ–π –∑–∞–ø—Ä–æ—Å –Ω–µ–∂–Ω–æ—Å—Ç–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ‚Üí –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
    if (userText && KEY_FLIRT.test(userText)) {
      const hit = list.filter(s => (s.keywords||[]).some(k => new RegExp(k,'i').test(userText)));
      if (hit.length) return weightedPick(hit);
      const romanticPool = list.filter(s => (s.moods||[]).some(m => ['tender','romantic','shy','cosy','playful'].includes(m)));
      if (romanticPool.length) return weightedPick(romanticPool);
    }

    // 1) ¬´—Ç—è–∂—ë–ª—ã–µ¬ª —Å–ª–æ–≤–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º –¢–û–õ–¨–ö–û —Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if (userText && DISCOURAGE.test(userText)) return null;

    // 2) –∫–ª—é—á–∏ –≤ –æ—Ç–≤–µ—Ç–µ –†–∏–Ω
    if (replyText){
      const hitKw = list.filter(s => (s.keywords||[]).some(k => new RegExp(k,'i').test(replyText)));
      if (hitKw.length) return weightedPick(hitKw);
    }

    // 3) –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫
    const tMood = windowPool || hourMood();
    const def = stickers.defaults?.byTime?.[tMood];
    if (def && Math.random() < (def.p ?? 0.1)) {
      const pool = list.filter(s => (s.moods||[]).some(m => def.moods.includes(m)));
      if (pool.length) return weightedPick(pool);
    }

    // 4) —Ñ–ª–∏—Ä—Ç –ø–æ –∫–ª—é—á–∞–º –≤ –æ—Ç–≤–µ—Ç–µ –†–∏–Ω
    if (replyText && KEY_FLIRT.test(replyText)) {
      const pool = list.filter(s => (s.moods||[]).some(m => ['romantic','playful','cosy','tender','shy'].includes(m)));
      if (pool.length && Math.random() < 0.35) return weightedPick(pool);
    }

    return null;
  }

  // --- INIT ---
  (async function init(){
    try {
      const [p1, p2, p3, p4] = await Promise.all([
        fetch('/data/rin_persona.json').then(r=>r.json()),
        fetch('/data/rin_phrases.json').then(r=>r.json()),
        fetch('/data/rin_schedule.json').then(r=>r.json()),
        // cache-buster –¥–ª—è iOS/PWA
        fetch('/data/rin_stickers.json?v=4').then(r=>r.json())
      ]);
      persona = p1; phrases = p2; schedule = p3; stickers = p4;
      console.log('stickers loaded:', stickers?.stickers?.length || 0);
    } catch (e) { console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å JSON', e); }

    history = loadHistory();
    if (history.length) {
      let prevDay = '';
      for (const m of history) {
        const d = new Date(m.ts || Date.now());
        const key = fmtDateKey(d);
        if (key !== prevDay) { ensureDateDivider(d); prevDay = key; }
        addBubble(m.content, m.role === 'user' ? 'user' : 'assistant', m.ts);
      }
    } else {
      ensureDateDivider(new Date());
      const greeting = '–ü—Ä–∏–≤–µ—Ç, —ç—Ç–æ —è ‚Äî –†–∏–Ω. –•–æ—á–µ—à—å, –±—É–¥—É —Ä—è–¥–æ–º –∏ –ø–æ–º–æ–≥—É —Ä–∞–∑–æ–±—Ä–∞—Ç—å –º—ã—Å–ª–∏? üå∏';
      addBubble(greeting, 'assistant');
      const st = pickStickerSmart(greeting, 'morning', ''); // –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
      if (st) { addStickerBubble(st.src, 'assistant'); chainStickerCount++; }
      history.push({ role:'assistant', content:greeting, ts: Date.now() });
      saveHistory(history);
    }

    setInterval(tryInitiateBySchedule, 60 * 1000);
    tryInitiateBySchedule();

    setInterval(()=>{
      const r = Math.random();
      peerStatus.textContent = r < 0.85 ? '–æ–Ω–ª–∞–π–Ω' : '–±—ã–ª–∞ –Ω–µ–¥–∞–≤–Ω–æ';
    }, 15000);
  })();

  function inWindow(local, fromHHMM, toHHMM){
    const [fh, fm] = fromHHMM.split(':').map(Number);
    const [th, tm] = toHHMM.split(':').map(Number);
    const min = local.getHours()*60 + local.getMinutes();
    const a = fh*60+fm, b = th*60+tm;
    return min >= a && min <= b;
  }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function addStickerBubble(src, who='assistant') {
    const row = document.createElement('div');
    row.className = 'row ' + (who === 'user' ? 'me' : 'her');
    row.innerHTML = (who === 'user'
      ? `<div class="bubble me"><img class="sticker" src="${src}" alt="sticker"/></div>`
      : `<img class="avatar small" src="/avatar.jpg" alt="–†–∏–Ω" />
         <div class="bubble her"><img class="sticker" src="${src}" alt="sticker"/></div>`
    );
    chatEl.appendChild(row);
    chatEl.scrollTop = chatEl.scrollHeight;
    return row;
  }

  async function tryInitiateBySchedule(){
    if (!schedule || !phrases) return;
    const d = nowLocal(); const dateKey = fmtDateKey(d);
    const lastKeyInStore = Object.keys(JSON.parse(localStorage.getItem(DAILY_INIT_KEY) || '{}')).pop();
    if (lastKeyInStore && lastKeyInStore !== dateKey) { localStorage.setItem(DAILY_INIT_KEY, JSON.stringify({})); chainStickerCount = 0; }
    const count = getInitCountFor(dateKey);
    if (count >= (schedule.max_daily_initiations || 2)) return;

    const win = (schedule.windows || []).find(w => inWindow(d, w.from, w.to) && Math.random() < (w.probability || 0.5));
    if (!win) return;

    const last = history[history.length-1];
    if (last && last.role === 'assistant' && d - new Date(last.ts || Date.now()) < 15*60*1000) return;

    const pool = phrases[win.pool] ? win.pool : 'morning';
    let text = pick(phrases[pool] || phrases.morning);

    peerStatus.textContent = '–ø–µ—á–∞—Ç–∞–µ—Ç‚Ä¶';
    const trow = addTyping();
    setTimeout(async () => {
      trow.remove();
      peerStatus.textContent = '–æ–Ω–ª–∞–π–Ω';
      addBubble(text, 'assistant');
      const st = pickStickerSmart(text, win.pool, ''); // –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤—ã –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é
      if (st) { addStickerBubble(st.src, 'assistant'); chainStickerCount++; }
      history.push({ role:'assistant', content:text, ts: Date.now() });
      saveHistory(history);
      bumpInitCount(dateKey);
    }, 1200 + Math.random()*1200);
  }

  formEl.addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = inputEl.value.trim();
    if (!text) return;
    addBubble(text, 'user');
    history.push({ role: 'user', content: text, ts: Date.now() });
    saveHistory(history);
    inputEl.value = '';
    inputEl.focus();
    peerStatus.textContent = '–ø–µ—á–∞—Ç–∞–µ—Ç‚Ä¶';
    const typingRow = addTyping();
    try {
      const res = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ history, pin: localStorage.getItem('rin-pin') })
      });
      const data = await res.json();
      typingRow.remove();
      if (!res.ok) throw new Error(data?.detail || data?.error || ('HTTP ' + res.status));
      peerStatus.textContent = '–æ–Ω–ª–∞–π–Ω';
      addBubble(data.reply, 'assistant');
      const st = pickStickerSmart(data.reply, null, text); // <‚Äî —Ç—É—Ç –ø–µ—Ä–µ–¥–∞—ë–º —Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      if (st) { addStickerBubble(st.src, 'assistant'); chainStickerCount++; }
      history.push({ role:'assistant', content:data.reply, ts: Date.now() });
      saveHistory(history);
    } catch (err) {
      typingRow.remove();
      peerStatus.textContent = '–æ–Ω–ª–∞–π–Ω';
      addBubble('–û–π‚Ä¶ —Å–≤—è–∑—å —à–∞–ª–∏—Ç. ' + (err?.message || ''), 'assistant');
    }
  });

  (function () {
    function keepBottom(){ setTimeout(() => { chatEl.scrollTop = chatEl.scrollHeight; }, 50); }
    inputEl.addEventListener('focus', keepBottom);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', keepBottom);
      window.visualViewport.addEventListener('scroll', keepBottom);
    }
  })();
  </script>
</body>
</html>
